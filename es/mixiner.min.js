/**
 * @license
 * Mixiner <https://shvabuk.github.io/mixiner>
 * Released under MIT license <https://shvabuk.github.io/mixiner/LICENSE.txt>
 * Copyright Shvab Ostap
 */

;const VERSION='1.0.4';export class Mixins{constructor(){this.collection=[],this.VERSION=VERSION}add(a){this.collection.push(a)}setParent(a){this.parent=a}has(a){return-1<this.collection.indexOf(a)||'undefined'!=typeof this.parent&&this.parent.has(a)}}const getProto=Object.getPrototypeOf||((a)=>a.__proto__);function getOwnPropsKeys(a){const b=Object.getOwnPropertyNames(a);return'undefined'==typeof Object.getOwnPropertySymbols?b:[].concat(b,Object.getOwnPropertySymbols(a))}function defineProps(a,b,c,d){const e=getOwnPropsKeys(b),f=getOwnPropsKeys(a),g='proto'===d?c.ignoreProtoProps:'static'===d?c.ignoreStaticProps:c.ignoreInstanceProps;for(let h=e.length;h--;)-1<g.indexOf(e[h])||(-1<f.indexOf(e[h])?c.resolve({target:a,mixin:b,options:c,type:d,propertyName:e[h]}):c.define(a,b,e[h]))}const has=Object.prototype.hasOwnProperty;function assignClasses(a,b,c){if(!has.call(a,'_mixins_')){const b=a._mixins_;Object.defineProperty(a,'_mixins_',{value:new Mixins,configurable:!0,writable:!0}),'undefined'!=typeof b&&a._mixins_.setParent(b)}'object'==typeof b._mixins_&&Array.isArray(b._mixins_.collection)&&b._mixins_.collection.forEach((b)=>assignClasses(a,b,c)),defineProps(a.prototype,b.prototype,c,'proto'),defineProps(a,b,c,'static'),a._mixins_.add(b)}function assign(a,b){const c=Object.keys(b);for(let d=c.length;d--;)a[c[d]]=b[c[d]];return a}function mixIn(a,b,c){const d=b.length;let e,f=-1;for(e='undefined'==typeof c?class{constructor(){b.forEach((b)=>{'undefined'==typeof b._mixinInstance_&&(b._mixinInstance_=new b),defineProps(this,b._mixinInstance_,a,'instance')})}}:class extends c{constructor(...c){const d=super(...c);return b.forEach((b)=>{'undefined'==typeof b._mixinInstance_&&(b._mixinInstance_=new b),defineProps(this,b._mixinInstance_,a,'instance')}),d}};++f<d;)assignClasses(e,b[f],a);return e}export function mixedBy(a,b){const c=getProto(a).constructor;return'object'==typeof c._mixins_&&'function'==typeof c._mixins_.has&&c._mixins_.has(b)}export function instanceOf(a,b){return mixedBy(a,b)||a instanceof b}const define=(a,b,c)=>{Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))},mixiner={VERSION,Mixins,options,mix,extend,mixedBy,instanceOf,config:{define,resolve:({target:a,mixin:b,propertyName:c})=>{define(a,b,c)},ignoreProtoProps:['constructor','apply','bind','call','isGenerator','toSource','toString','__proto__'],ignoreStaticProps:['arguments','arity','caller','length','name','displayName','prototype','__proto__','_mixinInstance_'],ignoreInstanceProps:['__proto__']}};mixiner.default=mixiner;export default mixiner;export function options(a){const b=assign(assign({},mixiner.config),a);return{mix:function(...a){return mixIn(b,a)},extend:function(a,...c){return mixIn(b,c,a)}}}export function extend(a,...b){return mixIn(mixiner.config,b,a)}export function mix(...a){return mixIn(mixiner.config,a)}mixiner.resolveConflict=(a)=>{const b=a.mixiner.VERSION.split('.').map(parseInt),c=mixiner.VERSION.split('.').map(parseInt);for(let d=-1;3>++d;){if(c[d]>b[d])return mixiner;if(c[d]<b[d])return a.mixiner}return a.mixiner};
//# sourceMappingURL=mixiner.min.js.map
